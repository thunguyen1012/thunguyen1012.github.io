---
title: Entity Framework - Entity Framework Core - Breaking changes in EF Core 8.0
published: true
date: 2024-07-17 03:29:40
tags: EFCore, Summary
description: EF Core 8 has been released and is now available for download.
image:
---
- Article

  - 03/10/2024

  - 8 contributors

## In this article

EF Core 8 has been released and is now available for download.

- Breaking changes in EF Core 7

- Breaking changes in EF Core 6

## Target Framework

EF Core 8 targets .NET 8. Applications targeting older .NET, .NET Core, and .NET Framework versions will need to update to target .NET 8.

## Summary

## High-impact changes



### ```Contains``` in LINQ queries may stop working on older SQL Server versions

Tracking Issue #13617

#### Old behavior

Previously, when the ```Contains``` operator was used in LINQ queries with a parameterized value list, EF generated SQL that was inefficient but worked on all SQL Server versions.

#### New behavior

Starting with EF Core 8.0, EF now generates SQL that is more efficient, but is unsupported on SQL Server 2014 and below.

This article shows how to set up an Azure SQL database which is incompatible with an older version of SQL Server.

#### Why

The previous SQL generated by EF Core for ```Contains``` inserted the parameterized values as constants in the SQL. For example, the following LINQ query:

```c#
var names = new[] { "Blog1", "Blog2" };

var blogs = await context.Blogs
    .Where(b => names.Contains(b.Name))
    .ToArrayAsync();
```

... would be translated to the following SQL:

```sql
SELECT [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] IN (N'Blog1', N'Blog2')
```

EF has released a new translation for SQL Server that avoids inserting constant values into the query.

For more information about this change, see this blog post.

#### Mitigations

If your database is SQL Server 2016 (13.x) or newer, or if you're using Azure SQL, check the configured compatibility level of your database via the following command:

```sql
SELECT name, compatibility_level FROM sys.databases;
```

If the compatibility level is below 130 (SQL Server 2016), consider modifying it to a newer value (documentation).

If your database version really is older than SQL Server 2016, or is set to an old compatibility level which you cannot change for some reason, configure EF Core to revert to the older, less efficient SQL as follows:

```c#
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    => optionsBuilder
        .UseSqlServer(@"<CONNECTION STRING>", o => o.UseCompatibilityLevel(120));
```



### Enums in JSON are stored as ints instead of strings by default

Tracking Issue #13617

#### Old behavior

In EF7, enums mapped to JSON are, by default, stored as string values in the JSON document.

#### New behavior

Starting with EF Core 8.0, EF now, by default, maps enums to integer values in the JSON document.

#### Why

The following example shows how to map values from an enum to a column in a relational database.

#### Mitigations

To continue using strings, configure the enum property with a conversion. For example:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().Property(e => e.Status).HasConversion<string>();
}
```

Or, for all properties of the enum type::

```csharp
protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    configurationBuilder.Properties<StatusEnum>().HaveConversion<string>();
}
```

## Medium-impact changes



### SQL Server ```date``` and ```time``` now scaffold to .NET ```DateOnly``` and ```TimeOnly```

Tracking Issue #24507

#### Old behavior

Previously, when scaffolding a SQL Server database with ```date``` or ```time``` columns, EF would generate entity properties with types DateTime and TimeSpan.

#### New behavior

Starting with EF Core 8.0, ```date``` and ```time``` are scaffolded as ```DateOnly``` and ```TimeOnly```.

#### Why

Microsoft has released new ```date``` and ```time``` types for .NET databases.

#### Mitigations

This change only affects users which regularly re-scaffold their database into an EF code model ("database-first" flow).

The ```EntityType.t4``` file has been updated to include two new scaffolding types.

```c#
var clrType = property.GetColumnType() switch
        {
            "date" when property.ClrType == typeof(DateOnly) => typeof(DateTime),
            "date" when property.ClrType == typeof(DateOnly?) => typeof(DateTime?),
            "time" when property.ClrType == typeof(TimeOnly) => typeof(TimeSpan),
            "time" when property.ClrType == typeof(TimeOnly?) => typeof(TimeSpan?),
            _ => property.ClrType
        };

        usings.AddRange(code.GetRequiredUsings(clrType));

        var needsNullable = Options.UseNullableReferenceTypes && property.IsNullable && !clrType.IsValueType;
        var needsInitializer = Options.UseNullableReferenceTypes && !property.IsNullable && !clrType.IsValueType;
#>
    public <#= code.Reference(clrType) #><#= needsNullable ? "?" : "" #> <#= property.Name #> { get; set; }<#= needsInitializer ? " = null!;" : "" #>
<#
```



### Boolean columns with a database generated value are no longer scaffolded as nullable

Tracking Issue #15070

#### Old behavior

Previously, non-nullable ```bool``` columns with a database default constraint were scaffolded as nullable ```bool```? properties.

#### New behavior

Starting with EF Core 8.0, non-nullable ```bool``` columns are always scaffolded as non-nullable properties.

#### Why

The value of a ```bool``` property will not be sent to the database if that value is ```false```.

#### Mitigations

This change only affects users which regularly re-scaffold their database into an EF code model ("database-first" flow).

The ```EntityType.t4``` file has been updated to generate a non-nullable property.

```c#
#>
        var propertyClrType = property.ClrType != typeof(bool)
                              || (property.GetDefaultValueSql() == null && property.GetDefaultValue() != null)
            ? property.ClrType
            : typeof(bool?);
#>
    public <#= code.Reference(propertyClrType) #><#= needsNullable ? "?" : "" #> <#= property.Name #> { get; set; }<#= needsInitializer ? " = null!;" : "" #>
<#
<#
```

## Low-impact changes



### SQLite ```Math``` methods now translate to SQL

Tracking Issue #18843

#### Old Behavior

Previously only the Abs, Max, Min, and Round methods on ```Math``` were translated to SQL. All other members would be evaluated on the client if they appeared in the final Select expression of a query.

#### New behavior

In EF Core 8.0, all ```Math``` methods with corresponding SQLite math functions are translated to SQL.

We've made some changes to our library to make it easier for you to write Mathematica-style functions to your application.

 ```Math``` functions can be written to SQL using the native library.

#### Why

If you're using the latest version of Mathematica, you might have noticed some changes.

We also collaborated with Eric Sink on the SQLitePCLRaw project to enable math functions in all of the native SQLite libraries provided as part of that project.

#### Mitigations

The simplest way to fix breaks is, when possible, to enable the math function is the native SQLite library by specifying the SQLITE_ENABLE_MATH_FUNCTIONS compile-time option.

If you don't control compilation of the native library, you can also fix breaks by create the functions yourself at runtime using the Microsoft.Data.Sqlite APIs.

```csharp
sqliteConnection
    .CreateFunction<double, double, double>(
        "pow",
        Math.Pow,
        isDeterministic: true);
```

Alternatively, you can force client-evaluation by splitting the Select expression into two parts separated by ```AsEnumerable```.

```csharp
// Before
var query = dbContext.Cylinders
    .Select(
        c => new
        {
            Id = c.Id
            // May throw "no such function: pow"
            Volume = Math.PI * Math.Pow(c.Radius, 2) * c.Height
        });

// After
var query = dbContext.Cylinders
    // Select the properties you'll need from the database
    .Select(
        c => new
        {
            c.Id,
            c.Radius,
            c.Height
        })
    // Switch to client-eval
    .AsEnumerable()
    // Select the final results
    .Select(
        c => new
        {
            Id = c.Id,
            Volume = Math.PI * Math.Pow(c.Radius, 2) * c.Height
        });
```



### ```ITypeBase``` replaces ```IEntityType``` in some APIs

Tracking Issue #13947

#### Old behavior

Previously, all mapped structural types were entity types.

#### New behavior

With the introduction of complex types in EF8, some APIs that were previously use an ```IEntityType``` now use ```ITypeBase``` so that the APIs can be used with either entity or complex types. This includes:

- ```IProperty.DeclaringEntityType``` is now obsolete and ```IProperty.DeclaringType``` should be used instead.

- ```IEntityTypeIgnoredConvention``` is now obsolete and ```ITypeIgnoredConvention``` should be used instead.

- ```IValueGeneratorSelector.Select``` now accepts an ```ITypeBase``` which may be, but does not have to be an ```IEntityType```.

#### Why

With the introduction of complex types in EF8, these APIs can be used with either ```IEntityType``` or ```IComplexType```.

#### Mitigations

The old APIs are obsoleted, but will not be removed until EF10. Code should be updated to use the new APIs ASAP.



### ```ValueConverter``` and ```ValueComparer``` expressions must use public APIs for the compiled model

Tracking Issue #24896

#### Old behavior

Previously, ```ValueConverter``` and ```ValueComparer``` definitions were not included in the compiled model, and so could contain arbitrary code.

#### New behavior

EF now extracts the expressions from the ```ValueConverter``` and ```ValueComparer``` objects and includes these C# in the compiled model. This means that these expressions must only use public API.

#### Why

The EF team is gradually moving more constructs into the compiled model to support using EF Core with AOT in the future.

#### Mitigations

Make the APIs used by the comparer public. For example, consider this simple converter:

```csharp
public class MyValueConverter : ValueConverter<string, byte[]>
{
    public MyValueConverter()
        : base(v => ConvertToBytes(v), v => ConvertToString(v))
    {
    }

    private static string ConvertToString(byte[] bytes)
        => ""; // ... TODO: Conversion code

    private static byte[] ConvertToBytes(string chars)
        => Array.Empty<byte>(); // ... TODO: Conversion code
}
```

To use this converter in a compiled model with EF8, the ```ConvertToString``` and ```ConvertToBytes``` methods must be made public. For example:

```csharp
public class MyValueConverter : ValueConverter<string, byte[]>
{
    public MyValueConverter()
        : base(v => ConvertToBytes(v), v => ConvertToString(v))
    {
    }

    public static string ConvertToString(byte[] bytes)
        => ""; // ... TODO: Conversion code

    public static byte[] ConvertToBytes(string chars)
        => Array.Empty<byte>(); // ... TODO: Conversion code
}
```



### ```ExcludeFromMigrations``` no longer excludes other tables in a TPC hierarchy

Tracking Issue #30079

#### Old behavior

Previously, using ```ExcludeFromMigrations``` on a table in a TPC hierarchy would also exclude other tables in the hierarchy.

#### New behavior

Starting with EF Core 8.0, ```ExcludeFromMigrations``` does not impact other tables.

#### Why

The old behavior was a bug and prevented migrations from being used to manage hierarchies across projects.

#### Mitigations

Use ```ExcludeFromMigrations``` explicitly on any other table that should be excluded.



### Non-shadow integer keys are persisted to Cosmos documents

Tracking Issue #31664

#### Old behavior

Previously, non-shadow integer properties that match the criteria to be a synthesized key property would not be persisted into the JSON document, but were instead re-synthesized on the way out.

#### New behavior

Starting with EF Core 8.0, these properties are now persisted.

#### Why

The old behavior was a bug and prevented properties that match the synthesized key criteria from being persisted to Cosmos.

#### Mitigations

If you want to persist a property's value to a model, set the property's persisted value to ```true```.

```C#
AppContext.SetSwitch("Microsoft.EntityFrameworkCore.Issue31664", isEnabled: true);
```



### Relational model is generated in the compiled model

Tracking Issue #24896

#### Old behavior

Previously, the relational model was computed at run-time even when using a compiled model.

#### New behavior

Starting with EF Core 8.0, the relational model is part of the generated compiled model. However, for particularly large models the generated file may fail to compile.

#### Why

This was done to further improve startup ```time```.

#### Mitigations

Edit the generated ```*ModelBuilder.cs``` file and remove the line AddRuntimeAnnotation("Relational:RelationalModel", CreateRelationalModel()); as well as the method CreateRelationalModel().



### Scaffolding may generate different navigation names

Tracking Issue #27832

#### Old behavior

 ```DbContext``` navigation names for relationships are now prefixed with a single foreign key column name.

#### New behavior

Starting with EF Core 8.0, common prefixes of column names from a composite foreign key are no longer used to generate navigation names.

#### Why

The following example shows how to change the naming rule for navigations.

#### Mitigations

How do I generate navigation names for my scaffolding?



### Discriminators now have a max length

Tracking Issue #10691

#### Old behavior

Previously, discriminator columns created for TPH inheritance mapping were configured as nvarchar(max) on SQL Server/Azure SQL, or the equivalent unbounded string type on other databases.

#### New behavior

If you want to create an ```AlterColumn``` with a max length that covers all the known discriminator values, you might want to consider using Migrations.

#### Why

nvarchar(max) columns are inefficient and unnecessary when the lengths of all possible values are known.

#### Mitigations

The column size can be made explicitly unbounded:

```csharp
modelBuilder.Entity<Foo>()
    .Property<string>("Discriminator")
    .HasMaxLength(-1);
```



### SQL Server key values are compared case-insensitively

Tracking Issue #27526

#### Old behavior

Previously, when tracking entities with string keys with the SQL Server/Azure SQL database providers, the key values were compared using the default .NET case-sensitive ordinal comparer.

#### New behavior

Starting with EF Core 8.0, SQL Server/Azure SQL string key values are compared using the default .NET case-insensitive ordinal comparer.

#### Why

This article shows how to change the way EF compares foreign key values to principal key values.

#### Mitigations

Case-sensitive comparisons can be used by setting a custom ```ValueComparer```. For example:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    var comparer = new ValueComparer<string>(
        (l, r) => string.Equals(l, r, StringComparison.Ordinal),
        v => v.GetHashCode(),
        v => v);

    modelBuilder.Entity<Blog>()
        .Property(e => e.Id)
        .Metadata.SetValueComparer(comparer);

    modelBuilder.Entity<Post>(
        b =>
        {
            b.Property(e => e.Id).Metadata.SetValueComparer(comparer);
            b.Property(e => e.BlogId).Metadata.SetValueComparer(comparer);
        });
}
```

Ref: [Breaking changes in EF Core 8 (EF8)](https://learn.microsoft.com/en-us/ef/core/what-is-new/ef-core-8.0/breaking-changes)