<!DOCTYPE html>
<html lang="en">
  <head>
    <title>What's new - What's new in 8 | Sudo's Notes</title>
    <meta charset="utf-8" />
    <meta http-equiv="content-type" content="text/html;" />
    <meta name="viewport" content="initial-scale=1.0 maximum-scale=1.0" />
    <meta property='og:image' content='https://thunguyen1012.github.io/img/default.jpg'><meta name='description' content='This article highlights the most significant changes in ASP.NET Core 8.0 with links to relevant documentation.'>
    <meta name="theme-color" content="#ffffff" />
    <meta
      name="google-site-verification"
      content="google-site-verification=kcDFRw1y16XjxYUB-datjB6MQB-CsjgE9h6lCalynC4"
    />

    <!-- Google Analytics -->
    <script>
      window.ga =
        window.ga ||
        function () {
          (ga.q = ga.q || []).push(arguments);
        };
      ga.l = +new Date();
      ga("create", "UA-120719369-1", "auto");
      ga("send", "pageview");
    </script>
    <script async src="https://www.google-analytics.com/analytics.js"></script>
    <!-- End Google Analytics -->
    <link href="../css/theme-dark.min.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="../css/highlight/railscasts.css" />
    <script src="../js/highlight.pack.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const content = document.getElementsByClassName("main")[0];
        const currentURL = window.location.href;

        function updateReadPercentage() {
          const contentHeight = content.offsetHeight;
          const viewportHeight = window.innerHeight;
          const scrollY = window.scrollY;
          let readPercentage =
            ((scrollY + viewportHeight) / contentHeight) * 100;
          readPercentage = Math.min(100, Math.max(0, readPercentage));

          const storedData = localStorage.getItem("readPercentage");
          const readingItems = JSON.parse(storedData) || [];
          const item = readingItems.find((item) => item.url === currentURL);
          if (item) {
            item.percent = Math.floor(readPercentage);
          } else {
            readingItems.push({
              url: currentURL,
              percent: Math.floor(readPercentage),
            });
          }
          localStorage.setItem("readPercentage", JSON.stringify(readingItems));
        }

        function loadReadPercentage() {
          const storedData = localStorage.getItem("readPercentage");
          const readingItems = JSON.parse(storedData) || [];
          const item = readingItems.find((item) => item.url === currentURL);
          if (item) {
            const contentHeight = content.offsetHeight;
            const viewportHeight = window.innerHeight;
            const scrollPosition =
              (item.percent / 100) * contentHeight - viewportHeight;

            window.scrollTo(0, scrollPosition);
          }
        }

        window.addEventListener("scroll", updateReadPercentage);
        window.addEventListener("resize", updateReadPercentage);
        loadReadPercentage();
        updateReadPercentage();
      });
    </script>
  </head>
  <body>
    <div class="header">
      <a href="/"><span class="avatar"></span></a>
    </div>
    <div class="container">
      <div class="main">
        <h1>What's new - What's new in 8</h1>
        <h2><a href="#in-this-article" aria-hidden="true" class="anchor" id="in-this-article"></a>In this article</h2>
<p>This article highlights the most significant changes in ASP.NET Core 8.0 with links to relevant documentation.</p>
<h2><a href="#blazor" aria-hidden="true" class="anchor" id="blazor"></a>Blazor</h2>
<h3><a href="#full-stack-web-ui" aria-hidden="true" class="anchor" id="full-stack-web-ui"></a>Full-stack web UI</h3>
<p>With the release of .NET 8, Blazor is a full-stack web UI framework for developing apps that render content at either the component or page level with:</p>
<ul>
<li>
<p>Static Server rendering (also called static server-side rendering, static SSR) to generate static HTML on the server.</p>
</li>
<li>
<p>Interactive Server rendering (also called interactive server-side rendering, interactive SSR) to generate interactive components with prerendering on the server.</p>
</li>
<li>
<p>Interactive WebAssembly rendering (also called client-side rendering, CSR, which is always assumed to be interactive) to generate interactive components on the client with prerendering on the server.</p>
</li>
<li>
<p>Interactive Auto (automatic) rendering to initially use the server-side ASP.NET Core runtime for content rendering and interactivity. The .NET WebAssembly runtime on the client is used for subsequent rendering and interactivity after the Blazor bundle is downloaded and the WebAssembly runtime activates. Interactive Auto rendering usually provides the fastest app startup experience.</p>
</li>
</ul>
<p>Interactive render modes also prerender content by default.</p>
<p>For more information, see the following articles:</p>
<ul>
<li>
<p>ASP.NET Core Blazor fundamentals: New sections on rendering and static/interactive concepts appear at the top of the article.</p>
</li>
<li>
<p>ASP.NET Core Blazor render modes</p>
</li>
<li>
<p>Migration coverage: Migrate from ASP.NET Core 7.0 to 8.0</p>
</li>
</ul>
<p>Examples throughout the Blazor documentation have been updated for use in Blazor Web Apps. Blazor Server examples remain in content versioned for .NET 7 or earlier.</p>
<h3><a href="#new-article-on-class-libraries-with-static-server-side-rendering-static-ssr)" aria-hidden="true" class="anchor" id="new-article-on-class-libraries-with-static-server-side-rendering-static-ssr)"></a>New article on class libraries with static server-side rendering (static SSR)</h3>
<p>We've added a new article that discusses component library authorship in Razor class libraries (RCLs) with static server-side rendering (static SSR).</p>
<p>For more information, see ASP.NET Core Razor class libraries (RCLs) with static server-side rendering (static SSR).</p>
<h3><a href="#new-article-on-http-caching-issues" aria-hidden="true" class="anchor" id="new-article-on-http-caching-issues"></a>New article on HTTP caching issues</h3>
<p>We've added a new article that discusses some of the common HTTP caching issues that can occur when upgrading Blazor apps across major versions and how to address HTTP caching issues.</p>
<p>For more information, see Avoid HTTP caching issues when upgrading ASP.NET Core Blazor apps.</p>
<h3><a href="#new-blazor-web-app-template" aria-hidden="true" class="anchor" id="new-blazor-web-app-template"></a>New Blazor Web App template</h3>
<p>We've introduced a new Blazor project template: the Blazor Web App template. The new template provides a single starting point for using Blazor components to build any style of web UI. The template combines the strengths of the existing Blazor Server and Blazor WebAssembly hosting models with the new Blazor capabilities added in .NET 8: static server-side rendering (static SSR), streaming rendering, enhanced navigation and form handling, and the ability to add interactivity using either Blazor Server or Blazor WebAssembly on a per-component basis.</p>
<p>As part of unifying the various Blazor hosting models into a single model in .NET 8, we're also consolidating the number of Blazor project templates. We removed the Blazor Server template, and the ASP.NET Core Hosted option has been removed from the Blazor WebAssembly template. Both of these scenarios are represented by options when using the Blazor Web App template.</p>
<blockquote>
<p class='note'>Note
Existing Blazor Server and Blazor WebAssembly apps remain supported in .NET 8. Optionally, these apps can be  updated to use the new full-stack web UI Blazor features.</p>
</blockquote>
<p>For more information on the new Blazor Web App template, see the following articles:</p>
<ul>
<li>
<p>Tooling for ASP.NET Core Blazor</p>
</li>
<li>
<p>ASP.NET Core Blazor project structure</p>
</li>
</ul>
<h3><a href="#new-js-initializers-for-blazor-web-apps" aria-hidden="true" class="anchor" id="new-js-initializers-for-blazor-web-apps"></a>New JS initializers for Blazor Web Apps</h3>
<p>For Blazor Server, Blazor WebAssembly, and Blazor Hybrid apps:</p>
<ul>
<li>
<p><code>beforeStart</code> is used for tasks such as customizing the loading process, logging level, and other options.</p>
</li>
<li>
<p><code>afterStarted</code> is used for tasks such as registering Blazor event listeners and custom event types.</p>
</li>
</ul>
<p>The preceding legacy JS initializers aren't invoked by default in a Blazor Web App. For Blazor Web Apps, a new set of JS initializers are used: <code>beforeWebStart</code>, <code>afterWebStarted</code>, <code>beforeServerStart</code>, <code>afterServerStarted</code>, <code>beforeWebAssemblyStart</code>, and <code>afterWebAssemblyStarted</code>.</p>
<p>For more information, see ASP.NET Core Blazor startup.</p>
<h3><a href="#split-of-prerendering-and-integration-guidance" aria-hidden="true" class="anchor" id="split-of-prerendering-and-integration-guidance"></a>Split of prerendering and integration guidance</h3>
<p>We've updated our coverage of the latest releases of .NET.</p>
<ul>
<li>
<p>Prerender ASP.NET Core Razor components</p>
</li>
<li>
<p>Integrate ASP.NET Core Razor components into ASP.NET Core apps</p>
</li>
</ul>
<h3><a href="#persist-component-state-in-a-blazor-web-app" aria-hidden="true" class="anchor" id="persist-component-state-in-a-blazor-web-app"></a>Persist component state in a Blazor Web App</h3>
<p>You can persist and read component state in a Blazor Web App using the existing PersistentComponentState service. This is useful for persisting component state during prerendering.</p>
<p>Blazor Web Apps automatically persist any registered app-level state created during prerendering, removing the need for the Persist Component State Tag Helper.</p>
<h3><a href="#form-handling-and-model-binding" aria-hidden="true" class="anchor" id="form-handling-and-model-binding"></a>Form handling and model binding</h3>
<p>Blazor components can now handle submitted form requests, including model binding and validating the request data. Components can implement forms with separate form handlers using the standard HTML <form> tag or using the existing <code>EditForm</code> component.</p>
<p>Form model binding in Blazor honors the data contract attributes (for example, <code>[DataMember]</code> and <code>[IgnoreDataMember]</code>) for customizing how the form data is bound to the model.</p>
<p>New antiforgery support is included in .NET 8. A new <code>AntiforgeryToken</code> component renders an antiforgery token as a hidden field, and the new <code>[RequireAntiforgeryToken]</code> attribute enables antiforgery protection. If an antiforgery check fails, a 400 (Bad Request) response is returned without form processing. The new antiforgery features are enabled by default for forms based on <code>Editform</code> and can be applied manually to standard HTML forms.</p>
<p>For more information, see ASP.NET Core Blazor forms overview.</p>
<h3><a href="#enhanced-navigation-and-form-handling" aria-hidden="true" class="anchor" id="enhanced-navigation-and-form-handling"></a>Enhanced navigation and form handling</h3>
<p>Static server-side rendering (static SSR) typically performs a full page refresh whenever the user navigates to a new page or submits a form. In .NET 8, Blazor can enhance page navigation and form handling by intercepting the request and performing a fetch request instead. Blazor then handles the rendered response content by patching it into the browser DOM. Enhanced navigation and form handling avoids the need for a full page refresh and preserves more of the page state, so pages load faster and more smoothly. Enhanced navigation is enabled by default when the Blazor script (blazor.web.js) is loaded. Enhanced form handling can be optionally enabled for specific forms.</p>
<p>New enhanced navigation API allows you to refresh the current page by calling <code>NavigationManager</code>.Refresh(bool forceLoad = false).</p>
<p>For more information, see the following sections of the Blazor Routing article:</p>
<ul>
<li>
<p>Enhanced navigation and form handling</p>
</li>
<li>
<p>Location changes</p>
</li>
</ul>
<h3><a href="#new-article-on-static-rendering-with-enhanced-navigation-for-js-interop" aria-hidden="true" class="anchor" id="new-article-on-static-rendering-with-enhanced-navigation-for-js-interop"></a>New article on static rendering with enhanced navigation for JS interop</h3>
<p>Blazor has released a new article explaining how to address a problem with enhanced page navigation in Blazor Web Apps.</p>
<p>ASP.NET Core Blazor JavaScript with static server-side rendering (static SSR)</p>
<h3><a href="#streaming-rendering" aria-hidden="true" class="anchor" id="streaming-rendering"></a>Streaming rendering</h3>
<p>You can now stream content updates on the response stream when using static server-side rendering (static SSR) with Blazor. Streaming rendering can improve the user experience for pages that perform long-running asynchronous tasks in order to fully render by rendering content as soon as it's available.</p>
<p>A streaming rendering approach allows you to render a page much more quickly than an asynchronous approach.</p>
<p>For more information, see ASP.NET Core Razor component rendering.</p>
<h3><a href="#inject-keyed-services-into-components" aria-hidden="true" class="anchor" id="inject-keyed-services-into-components"></a>Inject keyed services into components</h3>
<p>Blazor now supports injecting keyed services using the <code>[Inject]</code> attribute. Keys allow for scoping of registration and consumption of services when using dependency injection. Use the new <code>InjectAttribute.Key</code> property to specify the key for the service to inject:</p>
<pre><code class="language-csharp">[Inject(Key = &quot;my-service&quot;)]
public IMyService MyService { get; set; }
</code></pre>
<p>The <code>@inject</code> Razor directive doesn't support keyed services for this release, but work is tracked by Update <code>@inject</code> to support keyed services (dotnet/razor #9286) for a future .NET release.</p>
<p>For more information, see ASP.NET Core Blazor dependency injection.</p>
<h3><a href="#access-httpcontext-as-a-cascading-parameter" aria-hidden="true" class="anchor" id="access-httpcontext-as-a-cascading-parameter"></a>Access <code>HttpContext</code> as a cascading parameter</h3>
<p>You can now access the current <code>HttpContext</code> as a cascading parameter from a static server component:</p>
<pre><code class="language-csharp">[CascadingParameter]
public HttpContext? HttpContext { get; set; }
</code></pre>
<p>Accessing the <code>HttpContext</code> from a static server component might be useful for inspecting and modifying headers or other properties.</p>
<p>For an example that passes <code>HttpContext</code> state, access and refresh tokens, to components, see Server-side ASP.NET Core Blazor additional security scenarios.</p>
<h3><a href="#render-razor-components-outside-of-aspnet-core" aria-hidden="true" class="anchor" id="render-razor-components-outside-of-aspnet-core"></a>Render Razor components outside of ASP.NET Core</h3>
<p>You can now render Razor components outside the context of an HTTP request. You can render Razor components as HTML directly to a string or stream independently of the ASP.NET Core hosting environment. This is convenient for scenarios where you want to generate HTML fragments, such as for a generating email or static site content.</p>
<p>For more information, see Render Razor components outside of ASP.NET Core.</p>
<h3><a href="#sections-support" aria-hidden="true" class="anchor" id="sections-support"></a>Sections support</h3>
<p>The new <code>SectionOutlet</code> and <code>SectionContent</code> components in Blazor add support for specifying outlets for content that can be filled in later. Sections are often used to define placeholders in layouts that are then filled in by specific pages. Sections are referenced either by a unique name or using a unique object ID.</p>
<p>For more information, see ASP.NET Core Blazor sections.</p>
<h3><a href="#error-page-support" aria-hidden="true" class="anchor" id="error-page-support"></a>Error page support</h3>
<p>Blazor Web Apps can define a custom error page for use with the ASP.NET Core exception handling middleware. The Blazor Web App project template includes a default error page (Components/Pages/Error.razor) with similar content to the one used in MVC and Razor Pages apps. When the error page is rendered in response to a request from Exception Handling Middleware, the error page always renders as a static server component, even if interactivity is otherwise enabled.</p>
<p><code>Error.razor</code> in 8.0 reference source</p>
<h3><a href="#quickgrid" aria-hidden="true" class="anchor" id="quickgrid"></a>QuickGrid</h3>
<p>The Blazor QuickGrid component is no longer experimental and is now part of the Blazor framework in .NET 8.</p>
<p>QuickGrid is a high performance grid component for displaying data in tabular form. QuickGrid is built to be a simple and convenient way to display your data, while still providing powerful features, such as sorting, filtering, paging, and virtualization.</p>
<p>For more information, see ASP.NET Core Blazor QuickGrid component.</p>
<h3><a href="#route-to-named-elements" aria-hidden="true" class="anchor" id="route-to-named-elements"></a>Route to named elements</h3>
<p>Blazor now supports using client-side routing to navigate to a specific HTML element on a page using standard URL fragments. If you specify an identifier for an HTML element using the standard <code>id</code> attribute, Blazor correctly scrolls to that element when the URL fragment matches the element identifier.</p>
<p>For more information, see ASP.NET Core Blazor routing and navigation.</p>
<h3><a href="#root-level-cascading-values" aria-hidden="true" class="anchor" id="root-level-cascading-values"></a>Root-level cascading values</h3>
<p>Root-level cascading values can be registered for the entire component hierarchy. Named cascading values and subscriptions for update notifications are supported.</p>
<p>For more information, see ASP.NET Core Blazor cascading values and parameters.</p>
<h3><a href="#virtualize-empty-content" aria-hidden="true" class="anchor" id="virtualize-empty-content"></a><code>Virtualize</code> empty content</h3>
<p>Use the new <code>EmptyContent</code> parameter on the <code>Virtualize</code> component to supply content when the component has loaded and either <code>Items</code> is empty or <code>ItemsProviderResult&lt;T&gt;.TotalItemCount</code> is zero.</p>
<p>For more information, see ASP.NET Core Razor component virtualization.</p>
<h3><a href="#close-circuits-when-there-are-no-remaining-interactive-server-components" aria-hidden="true" class="anchor" id="close-circuits-when-there-are-no-remaining-interactive-server-components"></a>Close circuits when there are no remaining interactive server components</h3>
<p>Interactive server components handle web UI events using a real-time connection with the browser called a circuit. A circuit and its associated state are set up when a root interactive server component is rendered. The circuit is closed when there are no remaining interactive server components on the page, which frees up server resources.</p>
<h3><a href="#monitor-signalr-circuit-activity" aria-hidden="true" class="anchor" id="monitor-signalr-circuit-activity"></a>Monitor SignalR circuit activity</h3>
<p>You can now monitor inbound circuit activity in server-side apps using the new <code>CreateInboundActivityHandler</code> method on <code>CircuitHandler</code>. Inbound circuit activity is any activity sent from the browser to the server, such as UI events or JavaScript-to-.NET interop calls.</p>
<p>For more information, see ASP.NET Core Blazor SignalR guidance.</p>
<h3><a href="#faster-runtime-performance-with-the-jiterpreter" aria-hidden="true" class="anchor" id="faster-runtime-performance-with-the-jiterpreter"></a>Faster runtime performance with the Jiterpreter</h3>
<p>The Jiterpreter is a new runtime feature in .NET 8 that enables partial Just-in-Time (JIT) compilation support when running on WebAssembly to achieve improved runtime performance.</p>
<p>For more information, see Host and deploy ASP.NET Core Blazor WebAssembly.</p>
<h3><a href="#ahead-of-time-aot)-simd-and-exception-handling" aria-hidden="true" class="anchor" id="ahead-of-time-aot)-simd-and-exception-handling"></a>Ahead-of-time (AOT) SIMD and exception handling</h3>
<p>Blazor WebAssembly ahead-of-time (AOT) compilation now uses WebAssembly Fixed-width SIMD and WebAssembly Exception handling by default to improve runtime performance.</p>
<p>For more information, see the following articles:</p>
<ul>
<li>
<p>AOT: Single Instruction, Multiple Data (SIMD)</p>
</li>
<li>
<p>AOT: Exception handling</p>
</li>
</ul>
<h3><a href="#web-friendly-webcil-packaging" aria-hidden="true" class="anchor" id="web-friendly-webcil-packaging"></a>Web-friendly Webcil packaging</h3>
<p>Webcil is web-friendly packaging of .NET assemblies that removes content specific to native Windows execution to avoid issues when deploying to environments that block the download or use of <code>.dll</code> files. Webcil is enabled by default for Blazor WebAssembly apps.</p>
<p>For more information, see Host and deploy ASP.NET Core Blazor WebAssembly.</p>
<blockquote>
<p class='note'>Note
Prior to the release of .NET 8, guidance in Deployment layout for ASP.NET Core hosted Blazor WebAssembly apps addresses environments that block clients from downloading and executing DLLs with a multipart bundling approach. In .NET 8 or later, Blazor uses the Webcil file format to address this problem. Multipart bundling using the experimental NuGet package described by the WebAssembly deployment layout article isn't supported for Blazor apps in .NET 8 or later. For more information, see Enhance <code>Microsoft.AspNetCore.Components.WebAssembly.MultipartBundle</code> package to define a custom bundle format (dotnet/aspnetcore #36978). If you desire to continue using the multipart bundle package in .NET 8 or later apps, you can use the guidance in the article to create your own multipart bundling NuGet package, but it won't be supported by Microsoft.</p>
</blockquote>
<h3><a href="#blazor-webassembly-debugging-improvements" aria-hidden="true" class="anchor" id="blazor-webassembly-debugging-improvements"></a>Blazor WebAssembly debugging improvements</h3>
<p>When debugging .NET on WebAssembly, the now downloads symbol data from symbol locations in Visual Studio preferences.</p>
<p>Blazor has added debugging support for the Firefox web browser.</p>
<p>For more information, see Debug ASP.NET Core Blazor apps.</p>
<h3><a href="#content-security-policy-csp)-compatibility" aria-hidden="true" class="anchor" id="content-security-policy-csp)-compatibility"></a>Content Security Policy (CSP) compatibility</h3>
<p>Blazor WebAssembly no longer requires enabling the <code>unsafe-eval</code> script source when specifying a Content Security Policy (CSP).</p>
<p>For more information, see Enforce a Content Security Policy for ASP.NET Core Blazor.</p>
<h3><a href="#handle-caught-exceptions-outside-of-a-razor-components-lifecycle" aria-hidden="true" class="anchor" id="handle-caught-exceptions-outside-of-a-razor-components-lifecycle"></a>Handle caught exceptions outside of a Razor component's lifecycle</h3>
<p>Use <code>ComponentBase.DispatchExceptionAsync</code> in a Razor component to process exceptions thrown outside of the component's lifecycle call stack. This permits the component's code to treat exceptions as though they're lifecycle method exceptions. Thereafter, Blazor's error handling mechanisms, such as error boundaries, can process exceptions.</p>
<p>For more information, see Handle errors in ASP.NET Core Blazor apps.</p>
<h3><a href="#configure-the-net-webassembly-runtime" aria-hidden="true" class="anchor" id="configure-the-net-webassembly-runtime"></a>Configure the .NET WebAssembly runtime</h3>
<p>The .NET WebAssembly runtime can now be configured for Blazor startup.</p>
<p>For more information, see ASP.NET Core Blazor startup.</p>
<h3><a href="#configuration-of-connection-timeouts-in-hubconnectionbuilder" aria-hidden="true" class="anchor" id="configuration-of-connection-timeouts-in-hubconnectionbuilder"></a>Configuration of connection timeouts in <code>HubConnectionBuilder</code></h3>
<p>Prior workarounds for configuring hub connection timeouts can be replaced with formal SignalR hub connection builder timeout configuration.</p>
<p>For more information, see the following:</p>
<ul>
<li>
<p>ASP.NET Core Blazor SignalR guidance</p>
</li>
<li>
<p>Host and deploy ASP.NET Core Blazor WebAssembly</p>
</li>
<li>
<p>Host and deploy ASP.NET Core server-side Blazor apps</p>
</li>
</ul>
<h3><a href="#project-templates-shed-open-iconic" aria-hidden="true" class="anchor" id="project-templates-shed-open-iconic"></a><code>Project</code> templates shed Open Iconic</h3>
<p>The Blazor project templates no longer depend on Open Iconic for icons.</p>
<h3><a href="#support-for-dialog-cancel-and-close-events" aria-hidden="true" class="anchor" id="support-for-dialog-cancel-and-close-events"></a>Support for <code>dialog</code> <code>cancel</code> and <code>close</code> events</h3>
<p>Blazor now supports the <code>cancel</code> and <code>close</code> events on the <code>dialog</code> HTML element.</p>
<p>In the following example:</p>
<ul>
<li>
<p><code>OnClose</code> is called when the <code>my-dialog</code> <code>dialog</code> is closed with the Close button.</p>
</li>
<li>
<p><code>OnCancel</code> is called when the <code>dialog</code> is canceled with the Esc key. When an HTML <code>dialog</code> is dismissed with the Esc key, both the <code>cancel</code> and <code>close</code> events are triggered.</p>
</li>
</ul>
<pre><code class="language-razor">&lt;div&gt;
    &lt;p&gt;Output: @message&lt;/p&gt;

    &lt;button onclick=&quot;document.getElementById('my-dialog').showModal()&quot;&gt;
        Show modal dialog
    &lt;/button&gt;

    &lt;dialog id=&quot;my-dialog&quot; @onclose=&quot;OnClose&quot; @oncancel=&quot;OnCancel&quot;&gt;
        &lt;p&gt;Hi there!&lt;/p&gt;

        &lt;form method=&quot;dialog&quot;&gt;
            &lt;button&gt;Close&lt;/button&gt;
        &lt;/form&gt;
    &lt;/dialog&gt;
&lt;/div&gt;

@code {
    private string? message;

    private void OnClose(EventArgs e) =&gt; message += &quot;onclose, &quot;;

    private void OnCancel(EventArgs e) =&gt; message += &quot;oncancel, &quot;;
}
</code></pre>
<h3><a href="#blazor-identity-ui" aria-hidden="true" class="anchor" id="blazor-identity-ui"></a>Blazor Identity UI</h3>
<p>Blazor supports generating a full Blazor-based Identity UI when you choose the authentication option for <code>Individual</code> Accounts. You can either select the option for <code>Individual</code> Accounts in the new project <code>dialog</code> for Blazor Web Apps from Visual Studio or pass the <code>-au|--auth</code> option set to <code>Individual</code> from the command line when you create a new project.</p>
<p>For more information, see the following resources:</p>
<ul>
<li>
<p>Secure ASP.NET Core server-side Blazor apps</p>
</li>
<li>
<p>What's new with identity in .NET 8 (blog post)</p>
</li>
</ul>
<h3><a href="#secure-blazor-webassembly-with-aspnet-core-identity" aria-hidden="true" class="anchor" id="secure-blazor-webassembly-with-aspnet-core-identity"></a>Secure Blazor WebAssembly with ASP.NET Core Identity</h3>
<p>The Blazor documentation hosts a new article and sample app to cover securing a standalone Blazor WebAssembly app with ASP.NET Core Identity.</p>
<p>For more information, see the following resources:</p>
<ul>
<li>
<p>Secure ASP.NET Core Blazor WebAssembly with ASP.NET Core Identity</p>
</li>
<li>
<p>What's new with identity in .NET 8 (blog post)</p>
</li>
</ul>
<h3><a href="#blazor-server-with-yarp-routing" aria-hidden="true" class="anchor" id="blazor-server-with-yarp-routing"></a>Blazor Server with Yarp routing</h3>
<p>Routing and deep linking for Blazor Server with Yarp work correctly in .NET 8.</p>
<p>For more information, see Migrate from ASP.NET Core 7.0 to 8.0.</p>
<h3><a href="#blazor-hybrid" aria-hidden="true" class="anchor" id="blazor-hybrid"></a>Blazor Hybrid</h3>
<p>The following articles document changes for Blazor Hybrid in .NET 8:</p>
<ul>
<li>
<p>Troubleshoot ASP.NET Core Blazor Hybrid: A new article explains how to use <code>BlazorWebView</code> logging.</p>
</li>
<li>
<p>Build a .NET MAUI Blazor Hybrid app: The project template name .NET MAUI Blazor has changed to .NET MAUI Blazor Hybrid.</p>
</li>
<li>
<p>ASP.NET Core Blazor Hybrid: <code>BlazorWebView</code> gains a <code>TryDispatchAsync</code> method that calls a specified <code>Action&lt;ServiceProvider&gt;</code> asynchronously and passes in the scoped services available in Razor components. This enables code from the native UI to access scoped services such as <code>NavigationManager</code>.</p>
</li>
<li>
<p>ASP.NET Core Blazor Hybrid routing and navigation: Use the <code>BlazorWebView.StartPath</code> property to get or set the path for initial navigation within the Blazor navigation context when the Razor component is finished loading.</p>
</li>
</ul>
<h3><a href="#parameter]-attribute-is-no-longer-required-when-supplied-from-the-query-string" aria-hidden="true" class="anchor" id="parameter]-attribute-is-no-longer-required-when-supplied-from-the-query-string"></a><code>[Parameter]</code> attribute is no longer required when supplied from the query string</h3>
<p>The <code>[Parameter]</code> attribute is no longer required when supplying a parameter from the query string:</p>
<pre><code class="language-diff">- [Parameter]
  [SupplyParameterFromQuery]
</code></pre>
<h2><a href="#signalr" aria-hidden="true" class="anchor" id="signalr"></a>SignalR</h2>
<h3><a href="#new-approach-to-set-the-server-timeout-and-keep-alive-interval" aria-hidden="true" class="anchor" id="new-approach-to-set-the-server-timeout-and-keep-alive-interval"></a>New approach to set the server timeout and Keep-Alive interval</h3>
<p>ServerTimeout (default: 30 seconds) and KeepAliveInterval (default: 15 seconds) can be set directly on <code>HubConnectionBuilder</code>.</p>
<h4><a href="#prior-approach-for-javascript-clients" aria-hidden="true" class="anchor" id="prior-approach-for-javascript-clients"></a>Prior approach for JavaScript clients</h4>
<p>The following example shows the assignment of values that are double the default values in ASP.NET Core 7.0 or earlier:</p>
<pre><code class="language-javascript">var connection = new signalR.HubConnectionBuilder()
  .withUrl(&quot;/chatHub&quot;)
  .build();

connection.serverTimeoutInMilliseconds = 60000;
connection.keepAliveIntervalInMilliseconds = 30000;
</code></pre>
<h4><a href="#new-approach-for-javascript-clients" aria-hidden="true" class="anchor" id="new-approach-for-javascript-clients"></a>New approach for JavaScript clients</h4>
<p>The following example shows the new approach for assigning values that are double the default values in ASP.NET Core 8.0 or later:</p>
<pre><code class="language-javascript">var connection = new signalR.HubConnectionBuilder()
  .withUrl(&quot;/chatHub&quot;)
  .withServerTimeout(60000)
  .withKeepAlive(30000)
  .build();
</code></pre>
<h4><a href="#prior-approach-for-the-javascript-client-of-a-blazor-server-app" aria-hidden="true" class="anchor" id="prior-approach-for-the-javascript-client-of-a-blazor-server-app"></a>Prior approach for the JavaScript client of a Blazor Server app</h4>
<p>The following example shows the assignment of values that are double the default values in ASP.NET Core 7.0 or earlier:</p>
<pre><code class="language-javascript">Blazor.start({
  configureSignalR: function (builder) {
    let c = builder.build();
    c.serverTimeoutInMilliseconds = 60000;
    c.keepAliveIntervalInMilliseconds = 30000;
    builder.build = () =&gt; {
      return c;
    };
  }
});
</code></pre>
<h4><a href="#new-approach-for-the-javascript-client-of-server-side-blazor-app" aria-hidden="true" class="anchor" id="new-approach-for-the-javascript-client-of-server-side-blazor-app"></a>New approach for the JavaScript client of server-side Blazor app</h4>
<p>The following example shows the new approach for assigning values that are double the default values in ASP.NET Core 8.0 or later for Blazor Web Apps and Blazor Server.</p>
<p>Blazor Web App:</p>
<pre><code class="language-javascript">Blazor.start({
  circuit: {
    configureSignalR: function (builder) {
      builder.withServerTimeout(60000).withKeepAliveInterval(30000);
    }
  }
});
</code></pre>
<p>Blazor Server:</p>
<pre><code class="language-javascript">Blazor.start({
  configureSignalR: function (builder) {
    builder.withServerTimeout(60000).withKeepAliveInterval(30000);
  }
});
</code></pre>
<h4><a href="#prior-approach-for-net-clients" aria-hidden="true" class="anchor" id="prior-approach-for-net-clients"></a>Prior approach for .NET clients</h4>
<p>The following example shows the assignment of values that are double the default values in ASP.NET Core 7.0 or earlier:</p>
<pre><code class="language-csharp">var builder = new HubConnectionBuilder()
    .WithUrl(Navigation.ToAbsoluteUri(&quot;/chathub&quot;))
    .Build();

builder.ServerTimeout = TimeSpan.FromSeconds(60);
builder.KeepAliveInterval = TimeSpan.FromSeconds(30);

builder.On&lt;string, string&gt;(&quot;ReceiveMessage&quot;, (user, message) =&gt; ...

await builder.StartAsync();
</code></pre>
<h4><a href="#new-approach-for-net-clients" aria-hidden="true" class="anchor" id="new-approach-for-net-clients"></a>New approach for .NET clients</h4>
<p>The following example shows the new approach for assigning values that are double the default values in ASP.NET Core 8.0 or later:</p>
<pre><code class="language-csharp">var builder = new HubConnectionBuilder()
    .WithUrl(Navigation.ToAbsoluteUri(&quot;/chathub&quot;))
    .WithServerTimeout(TimeSpan.FromSeconds(60))
    .WithKeepAliveInterval(TimeSpan.FromSeconds(30))
    .Build();

builder.On&lt;string, string&gt;(&quot;ReceiveMessage&quot;, (user, message) =&gt; ...

await builder.StartAsync();
</code></pre>
<h3><a href="#signalr-stateful-reconnect" aria-hidden="true" class="anchor" id="signalr-stateful-reconnect"></a>SignalR stateful reconnect</h3>
<p>SignalR stateful reconnect is a software-defined networking (SDN) solution that allows network users to reconnect to the internet after a temporary disconnect.</p>
<p>Stateful reconnect achieves this by:</p>
<ul>
<li>
<p>Temporarily buffering data on the server and client.</p>
</li>
<li>
<p>Acknowledging messages received (ACK-ing) by both the server and client.</p>
</li>
<li>
<p>Recognizing when a connection is returning and replaying messages that might have been sent while the connection was down.</p>
</li>
</ul>
<p>Stateful reconnect is available in ASP.NET Core 8.0 and later.</p>
<p>Opt in to stateful reconnect at both the server hub endpoint and the client:</p>
<ul>
<li>Update the server hub endpoint configuration to enable the <code>AllowStatefulReconnects</code> option:</li>
</ul>
<pre><code class="language-csharp">app.MapHub&lt;MyHub&gt;(&quot;/hubName&quot;, options =&gt;
{
    options.AllowStatefulReconnects = ```true```;
});
</code></pre>
<p>Optionally, the maximum buffer size in bytes allowed by the server can be set globally or for a specific hub with the <code>StatefulReconnectBufferSize</code> option:
The <code>StatefulReconnectBufferSize</code> option set globally:
<code>builder.AddSignalR(o =&gt; o.StatefulReconnectBufferSize = 1000);</code></p>
<p>The <code>StatefulReconnectBufferSize</code> option set for a specific hub:
<code>builder.AddSignalR().AddHubOptions&lt;MyHub&gt;(o =&gt; o.StatefulReconnectBufferSize = 1000);</code></p>
<p>The <code>StatefulReconnectBufferSize</code> option is optional with a default of 100,000 bytes.</p>
<pre><code class="language-csharp">app.MapHub&lt;MyHub&gt;(&quot;/hubName&quot;, options =&gt;
{
    options.AllowStatefulReconnects = true;
});
</code></pre>
<pre><code class="language-csharp">builder.AddSignalR(o =&gt; o.StatefulReconnectBufferSize = 1000);
</code></pre>
<pre><code class="language-csharp">builder.AddSignalR().AddHubOptions&lt;MyHub&gt;(o =&gt; o.StatefulReconnectBufferSize = 1000);
</code></pre>
<ul>
<li>Update JavaScript or TypeScript client code to enable the <code>withStatefulReconnect</code> option:</li>
</ul>
<pre><code class="language-csharp">const builder = new signalR.HubConnectionBuilder()
  .withUrl(&quot;/hubname&quot;)
  .withStatefulReconnect({ ```bufferSize```: 1000 });  // Optional, defaults to 100,000
const connection = builder.build();
</code></pre>
<p>The <code>bufferSize</code> option is optional with a default of 100,000 bytes.</p>
<pre><code class="language-JavaScript">const builder = new signalR.HubConnectionBuilder()
  .withUrl(&quot;/hubname&quot;)
  .withStatefulReconnect({ bufferSize: 1000 });  // Optional, defaults to 100,000
const connection = builder.build();
</code></pre>
<ul>
<li>Update .NET client code to enable the <code>WithStatefulReconnect</code> option:</li>
</ul>
<pre><code class="language-csharp">  var builder = new ```HubConnectionBuilder```()
      .WithUrl(&quot;&lt;hub url&gt;&quot;)
      .WithStatefulReconnect();
  builder.Services.Configure&lt;HubConnectionOptions&gt;(o =&gt; o.StatefulReconnectBufferSize = 1000);
  var hubConnection = builder.Build();
</code></pre>
<p>The <code>StatefulReconnectBufferSize</code> option is optional with a default of 100,000 bytes.</p>
<pre><code class="language-csharp">var builder = new HubConnectionBuilder()
      .WithUrl(&quot;&lt;hub url&gt;&quot;)
      .WithStatefulReconnect();
  builder.Services.Configure&lt;HubConnectionOptions&gt;(o =&gt; o.StatefulReconnectBufferSize = 1000);
  var hubConnection = builder.Build();
</code></pre>
<p>For more information, see Configure stateful reconnect.</p>
<h2><a href="#minimal-apis" aria-hidden="true" class="anchor" id="minimal-apis"></a>Minimal APIs</h2>
<p>This section describes new features for minimal APIs. See also the section on Native AOT for more information relevant to minimal APIs.</p>
<h3><a href="#user-override-culture" aria-hidden="true" class="anchor" id="user-override-culture"></a>User override culture</h3>
<p>Starting in ASP.NET Core 8.0, the <code>RequestLocalizationOptions.CultureInfoUseUserOverride</code> property allows the application to decide whether or not to use nondefault Windows settings for the CultureInfo DateTimeFormat and NumberFormat properties. This has no impact on Linux. This directly corresponds to <code>UseUserOverride</code>.</p>
<pre><code class="language-csharp">app.UseRequestLocalization(options =&gt;
    {
        options.CultureInfoUseUserOverride = false;
    });
</code></pre>
<h3><a href="#binding-to-forms" aria-hidden="true" class="anchor" id="binding-to-forms"></a>Binding to forms</h3>
<p>Explicit binding to form values using the <code>[FromForm]</code> attribute is now supported. Parameters bound to the request with <code>[FromForm]</code> include an anti-forgery token. The anti-forgery token is validated when the request is processed.</p>
<p>The SwaggerForms library supports the following forms:</p>
<p>For more information, see:</p>
<ul>
<li>
<p>Explicit binding from form values.</p>
</li>
<li>
<p>Binding to forms with IFormCollection, IFormFile, and IFormFileCollection.</p>
</li>
<li>
<p>Form binding in minimal APIs</p>
</li>
</ul>
<p>Binding from forms is now supported for:</p>
<ul>
<li>
<p>Collections, for example List and Dictionary</p>
</li>
<li>
<p>Complex types, for example, <code>Todo</code> or <code>Project</code></p>
</li>
</ul>
<p>For more information, see Bind to collections and complex types from forms.</p>
<h3><a href="#antiforgery-with-minimal-apis" aria-hidden="true" class="anchor" id="antiforgery-with-minimal-apis"></a>Antiforgery with minimal APIs</h3>
<p>This release adds a middleware for validating antiforgery tokens, which are used to mitigate cross-site request forgery attacks. Call <code>AddAntiforgery</code> to register antiforgery services in DI. <code>WebApplicationBuilder</code> automatically adds the middleware when the antiforgery services have been registered in the DI container. Antiforgery tokens are used to mitigate cross-site request forgery attacks.</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder();

builder.Services.AddAntiforgery();

var app = builder.Build();

app.UseAntiforgery();

app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello World!&quot;);

app.Run();
</code></pre>
<p>The antiforgery middleware:</p>
<ul>
<li>
<p>Does not short-circuit the execution of the rest of the request pipeline.</p>
</li>
<li>
<p>Sets the IAntiforgeryValidationFeature in the <code>HttpContext</code>.Features of the current request.</p>
</li>
</ul>
<p>The antiforgery token is only validated if:</p>
<ul>
<li>
<p>The endpoint contains metadata implementing IAntiforgeryMetadata where <code>RequiresValidation=true</code>.</p>
</li>
<li>
<p>The HTTP method associated with the endpoint is a relevant HTTP method. The relevant methods are all HTTP methods except for TRACE, OPTIONS, HEAD, and GET.</p>
</li>
<li>
<p>The request is associated with a valid endpoint.</p>
</li>
</ul>
<p>For more information, see Antiforgery with Minimal APIs.</p>
<h3><a href="#new-iresettable-interface-in-objectpool" aria-hidden="true" class="anchor" id="new-iresettable-interface-in-objectpool"></a>New <code>IResettable</code> interface in <code>ObjectPool</code></h3>
<p>Microsoft.Extensions.ObjectPool provides support for pooling object instances in memory. Apps can use an object pool if the values are expensive to allocate or initialize.</p>
<p>In this release, we've made the object pool easier to use by adding the <code>IResettable</code> interface. Reusable types often need to be reset back to a default state between uses. <code>IResettable</code> types are automatically reset when returned to an object pool.</p>
<p>For more information, see the <code>ObjectPool</code> sample.</p>
<h2><a href="#native-aot" aria-hidden="true" class="anchor" id="native-aot"></a>Native AOT</h2>
<p>This release of ASP.NET Core adds support for .NET native ahead-of-time.</p>
<h3><a href="#libraries-and-native-aot" aria-hidden="true" class="anchor" id="libraries-and-native-aot"></a>Libraries and Native AOT</h3>
<p>Many of the popular libraries used in ASP.NET Core projects currently have some compatibility issues when used in a project targeting Native AOT, such as:</p>
<ul>
<li>
<p>Use of reflection to inspect and discover types.</p>
</li>
<li>
<p>Conditionally loading libraries at runtime.</p>
</li>
<li>
<p>Generating code on the fly to implement functionality.</p>
</li>
</ul>
<p>Libraries using these dynamic features need to be updated in order to work with Native AOT. They can be updated using tools like Roslyn source generators.</p>
<p>Library authors hoping to support Native AOT are encouraged to:</p>
<ul>
<li>
<p>Read about Native AOT compatibility requirements.</p>
</li>
<li>
<p>Prepare the library for trimming.</p>
</li>
</ul>
<h3><a href="#new-project-template" aria-hidden="true" class="anchor" id="new-project-template"></a>New project template</h3>
<p>The new ASP.NET Core Web API (Native AOT) project template (short name <code>webapiaot</code>) creates a project with AOT publish enabled. For more information, see The Web API (Native AOT) template.</p>
<h3><a href="#new-createslimbuilder-method" aria-hidden="true" class="anchor" id="new-createslimbuilder-method"></a>New <code>CreateSlimBuilder</code> method</h3>
<p>The <code>CreateSlimBuilder()</code> method used in the Web API (Native AOT) template initializes the <code>WebApplicationBuilder</code> with the minimum ASP.NET Core features necessary to run an app. The <code>CreateSlimBuilder</code> method includes the following features that are typically needed for an efficient development experience:</p>
<ul>
<li>
<p>JSON file configuration for <code>appsettings.json</code> and <code>appsettings.{EnvironmentName}.json</code>.</p>
</li>
<li>
<p>User secrets configuration.</p>
</li>
<li>
<p>Console logging.</p>
</li>
<li>
<p>Logging configuration.</p>
</li>
</ul>
<p>For more information, see The <code>CreateSlimBuilder</code> method.</p>
<h3><a href="#new-createemptybuilder-method" aria-hidden="true" class="anchor" id="new-createemptybuilder-method"></a>New <code>CreateEmptyBuilder</code> method</h3>
<p>There's another new <code>WebApplicationBuilder</code> factory method for building small apps that only contain necessary features: <code>WebApplication.CreateEmptyBuilder(WebApplicationOptions options)</code>. This <code>WebApplicationBuilder</code> is created with no built-in behavior. The app it builds contains only the services and middleware that are explicitly configured.</p>
<p>Here’s an example of using this API to create a small web application:</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateEmptyBuilder(new WebApplicationOptions());
builder.WebHost.UseKestrelCore();

var app = builder.Build();

app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync(&quot;Hello, World!&quot;);
    await next(context);
});

Console.WriteLine(&quot;Running...&quot;);
app.Run();
</code></pre>
<p>Publishing this code with Native AOT using .NET 8 Preview 7 on a linux-x64 machine results in a self-contained native executable of about 8.5 MB.</p>
<h3><a href="#reduced-app-size-with-configurable-https-support" aria-hidden="true" class="anchor" id="reduced-app-size-with-configurable-https-support"></a>Reduced app size with configurable HTTPS support</h3>
<p>We've further reduced Native AOT binary size for apps that don't need HTTPS or HTTP/3 support. Not using HTTPS or HTTP/3 is common for apps that run behind a TLS termination proxy (for example, hosted on Azure). The new <code>WebApplication.CreateSlimBuilder</code> method omits this functionality by default. It can be added by calling <code>builder.WebHost.UseKestrelHttpsConfiguration()</code> for HTTPS or <code>builder.WebHost.UseQuic()</code> for HTTP/3. For more information, see The <code>CreateSlimBuilder</code> method.</p>
<h3><a href="#json-serialization-of-compiler-generated-iasyncenumerablet>-types" aria-hidden="true" class="anchor" id="json-serialization-of-compiler-generated-iasyncenumerablet>-types"></a>JSON serialization of compiler-generated <code>IAsyncEnumerable&lt;T&gt;</code> types</h3>
<p>New features were added to <code>System.Text.Json</code> to better support Native AOT. These new features add capabilities for the source generation mode of <code>System.Text.Json</code>, because reflection isn't supported by AOT.</p>
<p>One of the new features is support for JSON serialization of <code>IAsyncEnumerable&lt;T&gt;</code> implementations implemented by the C# compiler. This support opens up their use in ASP.NET Core projects configured to publish Native AOT.</p>
<p>This API is useful in scenarios where a route handler uses <code>yield return</code> to asynchronously return an enumeration. For example, to materialize rows from a database query. For more information, see Unspeakable type support in the .NET 8 Preview 4 announcement.</p>
<p>For information abut other improvements in <code>System.Text.Json</code> source generation, see Serialization improvements in .NET 8.</p>
<h3><a href="#top-level-apis-annotated-for-trim-warnings" aria-hidden="true" class="anchor" id="top-level-apis-annotated-for-trim-warnings"></a>Top-level APIs annotated for trim warnings</h3>
<p>The main entry points to subsystems that don't work reliably with Native AOT are now annotated. When these methods are called from an application with Native AOT enabled, a warning is provided. For example, the following code produces a warning at the invocation of <code>AddControllers</code> because this API isn't trim-safe and isn't supported by Native AOT.</p>
<h3><a href="#request-delegate-generator" aria-hidden="true" class="anchor" id="request-delegate-generator"></a>Request delegate generator</h3>
<p>In order to make Minimal APIs compatible with Native AOT, we're introducing the Request Delegate Generator (RDG). The RDG is a source generator that does what the <code>RequestDelegateFactory</code> (RDF) does. That is, it turns the various <code>MapGet()</code>, <code>MapPost()</code>, and calls like them into <code>RequestDelegate</code> instances associated with the specified routes. But rather than doing it in-memory in an application when it starts, the RDG does it at compile time and generates C# code directly into the project. The RDG:</p>
<ul>
<li>
<p>Removes the runtime generation of this code.</p>
</li>
<li>
<p>Ensures that the types used in APIs are statically analyzable by the Native AOT tool-chain.</p>
</li>
<li>
<p>Ensures that required code isn't trimmed away.</p>
</li>
</ul>
<p>We're working to ensure that as many as possible of the Minimal API features are supported by the RDG and thus compatible with Native AOT.</p>
<p>The RDG is enabled automatically in a project when publishing with Native AOT is enabled. RDG can be manually enabled even when not using Native AOT by setting <code>&lt;EnableRequestDelegateGenerator&gt;true&lt;/EnableRequestDelegateGenerator&gt;</code> in the project file. This can be useful when initially evaluating a project's readiness for Native AOT, or to reduce the startup time of an app.</p>
<h3><a href="#improved-performance-using-interceptors" aria-hidden="true" class="anchor" id="improved-performance-using-interceptors"></a>Improved performance using Interceptors</h3>
<p>The Request Delegate Generator uses the new C# 12 interceptors compiler feature to support intercepting calls to minimal API Map methods with statically generated variants at runtime. The use of interceptors results in increased startup performance for apps compiled with <code>PublishAot</code>.</p>
<h3><a href="#logging-and-exception-handling-in-compile-time-generated-minimal-apis" aria-hidden="true" class="anchor" id="logging-and-exception-handling-in-compile-time-generated-minimal-apis"></a>Logging and exception handling in compile-time generated minimal APIs</h3>
<p>.NET 8 introduces the same support for APIs generated at compile time via the Request Delegate Generator (RDG).</p>
<h3><a href="#aot-and-systemtext.json" aria-hidden="true" class="anchor" id="aot-and-systemtext.json"></a>AOT and <code>System.Text.Json</code></h3>
<p>Minimal APIs are optimized for receiving and returning JSON payloads using <code>System.Text.Json</code>, so the compatibility requirements for JSON and Native AOT apply too. Native AOT compatibility requires the use of the <code>System.Text.Json</code> source generator. All types accepted as parameters to or returned from request delegates in Minimal APIs must be configured on a <code>JsonSerializerContext</code> that is registered via ASP.NET Core's dependency injection, for example:</p>
<pre><code class="language-csharp">// Register the JSON serializer context with DI
builder.Services.ConfigureHttpJsonOptions(options =&gt;
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
});

...

// Add types used in the minimal API app to source generated JSON serializer content
[JsonSerializable(typeof(Todo[]))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{

}
</code></pre>
<p>For more information about the TypeInfoResolverChain API, see the following resources:</p>
<ul>
<li>
<p>JsonSerializerOptions.TypeInfoResolverChain</p>
</li>
<li>
<p>Chain source generators</p>
</li>
<li>
<p>Changes to support source generation</p>
</li>
</ul>
<h3><a href="#libraries-and-native-aot-1" aria-hidden="true" class="anchor" id="libraries-and-native-aot-1"></a>Libraries and Native AOT</h3>
<p>Native AOT is a new programming language for ASP.NET Core projects.</p>
<p>Library authors wishing to learn more about preparing their libraries for Native AOT are encouraged to start by preparing their library for trimming and learning about the Native AOT compatibility requirements.</p>
<h2><a href="#kestrel-and-httpsys-servers" aria-hidden="true" class="anchor" id="kestrel-and-httpsys-servers"></a>Kestrel and <code>HTTP.sys</code> servers</h2>
<p>There are several new features for Kestrel and <code>HTTP.sys</code>.</p>
<h3><a href="#support-for-named-pipes-in-kestrel" aria-hidden="true" class="anchor" id="support-for-named-pipes-in-kestrel"></a>Support for named pipes in Kestrel</h3>
<p>Named pipes is a popular technology for building inter-process communication (IPC) between Windows apps. You can now build an IPC server using .NET, Kestrel, and named pipes.</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.WebHost.ConfigureKestrel(serverOptions =&gt;
{
    serverOptions.ListenNamedPipe(&quot;MyPipeName&quot;);
});
</code></pre>
<p>For more information about this feature and how to use .NET and gRPC to create an IPC server and client, see Inter-process communication with gRPC.</p>
<h3><a href="#performance-improvements-to-named-pipes-transport" aria-hidden="true" class="anchor" id="performance-improvements-to-named-pipes-transport"></a>Performance improvements to named pipes transport</h3>
<p>We’ve improved named pipe connection performance. Kestrel’s named pipe transport now accepts connections in parallel, and reuses NamedPipeServerStream instances.</p>
<p>Time to create 100,000 connections:</p>
<ul>
<li>
<p>Before : 5.916 seconds</p>
</li>
<li>
<p>After   : 2.374 seconds</p>
</li>
</ul>
<h3><a href="#http2-over-tls-(https)-support-on-macos-in-kestrel" aria-hidden="true" class="anchor" id="http2-over-tls-(https)-support-on-macos-in-kestrel"></a>HTTP/2 over TLS (HTTPS) support on macOS in Kestrel</h3>
<p>.NET 8 adds support for Application-Layer Protocol Negotiation (ALPN) to the ASP.NET Core Kestrel web server.</p>
<h3><a href="#certificate-file-watching-in-kestrel" aria-hidden="true" class="anchor" id="certificate-file-watching-in-kestrel"></a>Certificate file watching in Kestrel</h3>
<p>TLS certificates configured by path are now monitored for changes when <code>reloadOnChange</code> is passed to <code>KestrelServerOptions.Configure()</code>.  A change to the certificate file is treated the same way as a change to the configured path (that is, endpoints are reloaded).</p>
<p class='note'>Note that file deletions are specifically not tracked since they arise transiently and would crash the server if non-transient.</p>
<h3><a href="#warning-when-specified-http-protocols-wont-be-used" aria-hidden="true" class="anchor" id="warning-when-specified-http-protocols-wont-be-used"></a>Warning when specified HTTP protocols won't be used</h3>
<p>HTTP/1.x is the latest version of our web browser, and it supports TLS.</p>
<h3><a href="#http_ports-and-https_ports-config-keys" aria-hidden="true" class="anchor" id="http_ports-and-https_ports-config-keys"></a><code>HTTP_PORTS</code> and <code>HTTPS_PORTS</code> config keys</h3>
<p>Applications and containers are often only given a port to listen on, like 80, without additional constraints like host or path. <code>HTTP_PORTS</code> and <code>HTTPS_PORTS</code> are new config keys that allow specifying the listening ports for the Kestrel and <code>HTTP.sys</code> servers. These can be defined with the <code>DOTNET_</code> or <code>ASPNETCORE_</code> environment variable prefixes, or specified directly through any other config input like <code>appsettings.json</code>. Each is a semicolon delimited list of port values. For example:</p>
<pre><code class="language-cli">ASPNETCORE_HTTP_PORTS=80;8080
ASPNETCORE_HTTPS_PORTS=443;8081
</code></pre>
<p>This is shorthand for the following, which specifies the scheme (HTTP or HTTPS) and any host or IP:</p>
<pre><code class="language-cli">ASPNETCORE_URLS=http://*:80/;http://*:8080/;https://*:443/;https://*:8081/
</code></pre>
<p>For more information, see Configure endpoints for the ASP.NET Core Kestrel web server and <code>HTTP.sys</code> web server implementation in ASP.NET Core.</p>
<h3><a href="#sni-host-name-in-itlshandshakefeature" aria-hidden="true" class="anchor" id="sni-host-name-in-itlshandshakefeature"></a>SNI host name in ITlsHandshakeFeature</h3>
<p>The Server Name Indication (SNI) host name is now exposed in the HostName property of the <code>ITlsHandshakeFeature</code> interface.</p>
<p>The Secure Network Interface (SNI) is a key part of the Transport Layer Security (TLS) protocol.</p>
<p>TLS (Transport Layer Security) is a secure socket layer protocol that connects computers to the internet.</p>
<p>This documentation describes how to expose the host name of a SNI bindings in a declarative manner.</p>
<p>For more information, see <code>ITlsHandshakeFeature.HostName</code>.</p>
<h3><a href="#ihttpsysrequesttimingfeature" aria-hidden="true" class="anchor" id="ihttpsysrequesttimingfeature"></a>IHttpSysRequestTimingFeature</h3>
<p><code>IHttpSysRequestTimingFeature</code> provides detailed timing information for requests when using the <code>HTTP.sys</code> server and In-process hosting with IIS:</p>
<ul>
<li>
<p>Timestamps are obtained using <code>QueryPerformanceCounter</code>.</p>
</li>
<li>
<p>The timestamp frequency can be obtained via <code>QueryPerformanceFrequency</code>.</p>
</li>
<li>
<p>The index of the timing can be cast to <code>HttpSysRequestTimingType</code> to know what the timing represents.</p>
</li>
<li>
<p>The value might be 0 if the timing isn't available for the current request.</p>
</li>
</ul>
<p><code>IHttpSysRequestTimingFeature.TryGetTimestamp</code> retrieves the timestamp for the provided timing type:</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Http.Features;
using Microsoft.AspNetCore.Server.HttpSys;
var builder = WebApplication.CreateBuilder(args);

builder.WebHost.UseHttpSys();

var app = builder.Build();

app.Use((context, next) =&gt;
{
    var feature = context.Features.GetRequiredFeature&lt;IHttpSysRequestTimingFeature&gt;();

    var loggerFactory = context.RequestServices.GetRequiredService&lt;ILoggerFactory&gt;();
    var logger = loggerFactory.CreateLogger(&quot;Sample&quot;);

    var timingType = HttpSysRequestTimingType.RequestRoutingEnd;

    if (feature.TryGetTimestamp(timingType, out var timestamp))
    {
        logger.LogInformation(&quot;Timestamp {timingType}: {timestamp}&quot;,
                                          timingType, timestamp);
    }
    else
    {
        logger.LogInformation(&quot;Timestamp {timingType}: not available for the &quot;
                                           + &quot;current request&quot;,    timingType);
    }

    return next(context);
});

app.MapGet(&quot;/&quot;, () =&gt; Results.Ok());

app.Run();
</code></pre>
<p>For more information, see Get detailed timing information with <code>IHttpSysRequestTimingFeature</code> and Timing information and In-process hosting with IIS.</p>
<h3><a href="#httpsys:-opt-in-support-for-kernel-mode-response-buffering" aria-hidden="true" class="anchor" id="httpsys:-opt-in-support-for-kernel-mode-response-buffering"></a><code>HTTP.sys</code>: opt-in support for kernel-mode response buffering</h3>
<p>In some scenarios, high volumes of small writes with high latency can cause significant performance impact to <code>HTTP.sys</code>. This impact is due to the lack of a Pipe buffer in the <code>HTTP.sys</code> implementation. To improve performance in these scenarios, support for response buffering has been added to <code>HTTP.sys</code>. Enable buffering by setting <code>HttpSysOptions.EnableKernelResponseBuffering</code> to <code>true</code>.</p>
<p>This paper describes how to enable response buffering in an app.</p>
<p>Apps that use asynchronous I/O and that can have more than one write outstanding at a time should not use this flag. Enabling this flag can result in higher CPU and memory usage by HTTP.Sys.</p>
<h2><a href="#authentication-and-authorization" aria-hidden="true" class="anchor" id="authentication-and-authorization"></a>Authentication and authorization</h2>
<p>ASP.NET Core 8 adds new features to authentication and authorization.</p>
<h3><a href="#identity-api-endpoints" aria-hidden="true" class="anchor" id="identity-api-endpoints"></a>Identity API endpoints</h3>
<p><code>MapIdentityApi&lt;TUser&gt;</code> is a new extension method that adds two API endpoints (<code>/register</code> and <code>/login</code>). The main goal of the <code>MapIdentityApi</code> is to make it easy for developers to use ASP.NET Core Identity for authentication in JavaScript-based single page apps (SPA) or Blazor apps. Instead of using the default UI provided by ASP.NET Core Identity, which is based on Razor Pages, <code>MapIdentityApi</code> adds JSON API endpoints that are more suitable for SPA apps and nonbrowser apps. For more information, see Identity API endpoints.</p>
<h3><a href="#iauthorizationrequirementdata" aria-hidden="true" class="anchor" id="iauthorizationrequirementdata"></a><code>IAuthorizationRequirementData</code></h3>
<p>Prior to ASP.NET Core 8, adding a parameterized authorization policy to an endpoint required implementing an:</p>
<ul>
<li>
<p><code>AuthorizeAttribute</code> for each policy.</p>
</li>
<li>
<p><code>AuthorizationPolicyProvider</code> to process a custom policy from a string-based contract.</p>
</li>
<li>
<p><code>AuthorizationRequirement</code> for the policy.</p>
</li>
<li>
<p><code>AuthorizationHandler</code> for each requirement.</p>
</li>
</ul>
<p>For example, consider the following sample written for ASP.NET Core 7.0:</p>
<pre><code class="language-csharp">using AuthRequirementsData.Authorization;
using Microsoft.AspNetCore.Authorization;

var builder = WebApplication.CreateBuilder();

builder.Services.AddAuthentication().AddJwtBearer();
builder.Services.AddAuthorization();
builder.Services.AddControllers();
builder.Services.AddSingleton&lt;IAuthorizationPolicyProvider, MinimumAgePolicyProvider&gt;();
builder.Services.AddSingleton&lt;IAuthorizationHandler, MinimumAgeAuthorizationHandler&gt;();

var app = builder.Build();

app.MapControllers();

app.Run();
</code></pre>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;

namespace AuthRequirementsData.Controllers;

[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class GreetingsController : Controller
{
    [MinimumAgeAuthorize(16)]
    [HttpGet(&quot;hello&quot;)]
    public string Hello() =&gt; $&quot;Hello {(HttpContext.User.Identity?.Name ?? &quot;world&quot;)}!&quot;;
}
</code></pre>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Authorization;
using System.Globalization;
using System.Security.Claims;

namespace AuthRequirementsData.Authorization;

class MinimumAgeAuthorizationHandler : AuthorizationHandler&lt;MinimumAgeRequirement&gt;
{
    private readonly ILogger&lt;MinimumAgeAuthorizationHandler&gt; _logger;

    public MinimumAgeAuthorizationHandler(ILogger&lt;MinimumAgeAuthorizationHandler&gt; logger)
    {
        _logger = logger;
    }

    // Check whether a given MinimumAgeRequirement is satisfied or not for a particular
    // context.
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
                                               MinimumAgeRequirement requirement)
    {
        // Log as a warning so that it's very clear in sample output which authorization
        // policies(and requirements/handlers) are in use.
        _logger.LogWarning(&quot;Evaluating authorization requirement for age &gt;= {age}&quot;,
                                                                    requirement.Age);

        // Check the user's age
        var dateOfBirthClaim = context.User.FindFirst(c =&gt; c.Type ==
                                                                 ClaimTypes.DateOfBirth);
        if (dateOfBirthClaim != null)
        {
            // If the user has a date of birth claim, check their age
            var dateOfBirth = Convert.ToDateTime(dateOfBirthClaim.Value, CultureInfo.InvariantCulture);
            var age = DateTime.Now.Year - dateOfBirth.Year;
            if (dateOfBirth &gt; DateTime.Now.AddYears(-age))
            {
                // Adjust age if the user hasn't had a birthday yet this year.
                age--;
            }

            // If the user meets the age criterion, mark the authorization requirement
            // succeeded.
            if (age &gt;= requirement.Age)
            {
                _logger.LogInformation(&quot;Minimum age authorization requirement {age} satisfied&quot;,
                                         requirement.Age);
                context.Succeed(requirement);
            }
            else
            {
                _logger.LogInformation(&quot;Current user's DateOfBirth claim ({dateOfBirth})&quot; +
                    &quot; does not satisfy the minimum age authorization requirement {age}&quot;,
                    dateOfBirthClaim.Value,
                    requirement.Age);
            }
        }
        else
        {
            _logger.LogInformation(&quot;No DateOfBirth claim present&quot;);
        }

        return Task.CompletedTask;
    }
}
</code></pre>
<p>The complete sample is here in the AspNetCore.Docs.Samples repository.</p>
<p>ASP.NET Core 8 introduces the <code>IAuthorizationRequirementData</code> interface. The <code>IAuthorizationRequirementData</code> interface allows the attribute definition to specify the requirements associated with the authorization policy. Using <code>IAuthorizationRequirementData</code>, the preceding custom authorization policy code can be written with fewer lines of code. The updated <code>Program.cs</code> file:</p>
<pre><code class="language-diff">using AuthRequirementsData.Authorization;
  using Microsoft.AspNetCore.Authorization;
  
  var builder = WebApplication.CreateBuilder();
  
  builder.Services.AddAuthentication().AddJwtBearer();
  builder.Services.AddAuthorization();
  builder.Services.AddControllers();
- builder.Services.AddSingleton&lt;IAuthorizationPolicyProvider, MinimumAgePolicyProvider&gt;();
  builder.Services.AddSingleton&lt;IAuthorizationHandler, MinimumAgeAuthorizationHandler&gt;();
  
  var app = builder.Build();
  
  app.MapControllers();
  
  app.Run();
</code></pre>
<p>The updated <code>MinimumAgeAuthorizationHandler</code>:</p>
<pre><code class="language-diff">using Microsoft.AspNetCore.Authorization;
using System.Globalization;
using System.Security.Claims;

namespace AuthRequirementsData.Authorization;

- class MinimumAgeAuthorizationHandler : AuthorizationHandler&lt;MinimumAgeRequirement&gt;
+ class MinimumAgeAuthorizationHandler : AuthorizationHandler&lt;MinimumAgeAuthorizeAttribute&gt;
{
    private readonly ILogger&lt;MinimumAgeAuthorizationHandler&gt; _logger;

    public MinimumAgeAuthorizationHandler(ILogger&lt;MinimumAgeAuthorizationHandler&gt; logger)
    {
        _logger = logger;
    }

    // Check whether a given MinimumAgeRequirement is satisfied or not for a particular
    // context
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
-                                              MinimumAgeRequirement requirement)
+                                              MinimumAgeAuthorizeAttribute requirement)
    {
        // Remaining code omitted for brevity.
</code></pre>
<p>The complete updated sample can be found here.</p>
<p>See Custom authorization policies with <code>IAuthorizationRequirementData</code> for a detailed examination of the new sample.</p>
<h3><a href="#securing-swagger-ui-endpoints" aria-hidden="true" class="anchor" id="securing-swagger-ui-endpoints"></a>Securing Swagger UI endpoints</h3>
<p>Swagger UI endpoints can now be secured in production environments by calling <code>MapSwagger().RequireAuthorization</code>. For more information, see Securing Swagger UI endpoints</p>
<h2><a href="#miscellaneous" aria-hidden="true" class="anchor" id="miscellaneous"></a>Miscellaneous</h2>
<p>The following sections describe miscellaneous new features in ASP.NET Core 8.</p>
<h3><a href="#keyed-services-support-in-dependency-injection" aria-hidden="true" class="anchor" id="keyed-services-support-in-dependency-injection"></a>Keyed services support in Dependency Injection</h3>
<p>Keyed services refers to a mechanism for registering and retrieving Dependency Injection (DI) services using keys. A service is associated with a key by calling <code>AddKeyedSingleton</code> (or <code>AddKeyedScoped</code> or <code>AddKeyedTransient</code>) to register it. Access a registered service by specifying the key with the <code>[FromKeyedServices]</code> attribute. The following code shows how to use keyed services:</p>
<pre><code class="language-csharp">using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddKeyedSingleton&lt;ICache, BigCache&gt;(&quot;big&quot;);
builder.Services.AddKeyedSingleton&lt;ICache, SmallCache&gt;(&quot;small&quot;);
builder.Services.AddControllers();

var app = builder.Build();

app.MapGet(&quot;/big&quot;, ([FromKeyedServices(&quot;big&quot;)] ICache bigCache) =&gt; bigCache.Get(&quot;date&quot;));
app.MapGet(&quot;/small&quot;, ([FromKeyedServices(&quot;small&quot;)] ICache smallCache) =&gt;
                                                               smallCache.Get(&quot;date&quot;));

app.MapControllers();

app.Run();

public interface ICache
{
    object Get(string key);
}
public class BigCache : ICache
{
    public object Get(string key) =&gt; $&quot;Resolving {key} from big cache.&quot;;
}

public class SmallCache : ICache
{
    public object Get(string key) =&gt; $&quot;Resolving {key} from small cache.&quot;;
}

[ApiController]
[Route(&quot;/cache&quot;)]
public class CustomServicesApiController : Controller
{
    [HttpGet(&quot;big-cache&quot;)]
    public ActionResult&lt;object&gt; GetOk([FromKeyedServices(&quot;big&quot;)] ICache cache)
    {
        return cache.Get(&quot;data-mvc&quot;);
    }
}

public class MyHub : Hub
{
    public void Method([FromKeyedServices(&quot;small&quot;)] ICache cache)
    {
        Console.WriteLine(cache.Get(&quot;signalr&quot;));
    }
}
</code></pre>
<h3><a href="#visual-studio-project-templates-for-spa-apps-with-aspnet-core-backend" aria-hidden="true" class="anchor" id="visual-studio-project-templates-for-spa-apps-with-aspnet-core-backend"></a>Visual Studio project templates for SPA apps with ASP.NET Core backend</h3>
<p>Visual Studio project templates are now the recommended way to create single-page apps (SPAs) that have an ASP.NET Core backend. Templates are provided that create apps based on the JavaScript frameworks Angular, React, and Vue. These templates:</p>
<ul>
<li>
<p>Create a Visual Studio solution with a frontend project and a backend project.</p>
</li>
<li>
<p>Use the Visual Studio project type for JavaScript and TypeScript (.esproj) for the frontend.</p>
</li>
<li>
<p>Use an ASP.NET Core project for the backend.</p>
</li>
</ul>
<p>For more information about the Visual Studio templates and how to access the legacy templates, see Overview of Single Page Apps (SPAs) in ASP.NET Core</p>
<h3><a href="#support-for-generic-attributes" aria-hidden="true" class="anchor" id="support-for-generic-attributes"></a>Support for generic attributes</h3>
<p>The latest release of C# introduces support for generic attributes.</p>
<pre><code class="language-diff">[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class TodosController : Controller
{
  [HttpGet(&quot;/&quot;)]
- [ProducesResponseType(typeof(Todo), StatusCodes.Status200OK)]
+ [ProducesResponseType&lt;Todo&gt;(StatusCodes.Status200OK)]
  public Todo Get() =&gt; new Todo(1, &quot;Write a sample&quot;, DateTime.Now, false);
}
</code></pre>
<p>Generic variants are supported for the following attributes:</p>
<ul>
<li>
<p>[ProducesResponseType<T>]</p>
</li>
<li>
<p>[Produces<T>]</p>
</li>
<li>
<p>[MiddlewareFilter<T>]</p>
</li>
<li>
<p>[ModelBinder<T>]</p>
</li>
<li>
<p>[ModelMetadataType<T>]</p>
</li>
<li>
<p>[ServiceFilter<T>]</p>
</li>
<li>
<p>[TypeFilter<T>]</p>
</li>
</ul>
<h3><a href="#code-analysis-in-aspnet-core-apps" aria-hidden="true" class="anchor" id="code-analysis-in-aspnet-core-apps"></a>Code analysis in ASP.NET Core apps</h3>
<p>The new analyzers shown in the following table are available in ASP.NET Core 8.0.</p>
<table><thead>
<tr>
<th>Diagnostic ID</th>
<th>Breaking or nonbreaking</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="../diagnostics/asp0016?view=aspnetcore-8.0" data-linktype="relative-path">ASP0016</a></td>
<td>Nonbreaking</td>
<td>Don't return a value from RequestDelegate</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0019?view=aspnetcore-8.0" data-linktype="relative-path">ASP0019</a></td>
<td>Nonbreaking</td>
<td>Suggest using IHeaderDictionary.Append or the indexer</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0020?view=aspnetcore-8.0" data-linktype="relative-path">ASP0020</a></td>
<td>Nonbreaking</td>
<td>Complex types referenced by route parameters must be parsable</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0021?view=aspnetcore-8.0" data-linktype="relative-path">ASP0021</a></td>
<td>Nonbreaking</td>
<td>The return type of the BindAsync method must be <code>ValueTask&lt;T&gt;</code></td>
</tr>
<tr>
<td><a href="../diagnostics/asp0022?view=aspnetcore-8.0" data-linktype="relative-path">ASP0022</a></td>
<td>Nonbreaking</td>
<td>Route conflict detected between route handlers</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0023?view=aspnetcore-8.0" data-linktype="relative-path">ASP0023</a></td>
<td>Nonbreaking</td>
<td>MVC: Route conflict detected between route handlers</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0024?view=aspnetcore-8.0" data-linktype="relative-path">ASP0024</a></td>
<td>Nonbreaking</td>
<td>Route handler has multiple parameters with the <code>[FromBody]</code> attribute</td>
</tr>
<tr>
<td><a href="../diagnostics/asp0025?view=aspnetcore-8.0" data-linktype="relative-path">ASP0025</a></td>
<td>Nonbreaking</td>
<td>Use AddAuthorizationBuilder</td>
</tr>
</tbody></table>
<h3><a href="#route-tooling" aria-hidden="true" class="anchor" id="route-tooling"></a>Route tooling</h3>
<p>ASP.NET Core is built on routing. Minimal APIs, Web APIs, Razor Pages, and Blazor all use routes to customize how HTTP requests map to code.</p>
<p>In .NET 8 we've invested in a suite of new features to make routing easier to learn and use. These new features include:</p>
<ul>
<li>
<p>Route syntax highlighting</p>
</li>
<li>
<p>Autocomplete of parameter and route names</p>
</li>
<li>
<p>Autocomplete of route constraints</p>
</li>
<li>
<p>Route analyzers and fixers</p>
<ul>
<li>
<p>Route syntax analyzer</p>
</li>
<li>
<p>Mismatched parameter optionality analyzer and fixer</p>
</li>
<li>
<p>Ambiguous Minimal API and Web API route analyzer</p>
</li>
</ul>
</li>
<li>
<p>Support for Minimal APIs, Web APIs, and Blazor</p>
</li>
</ul>
<p>For more information, see Route tooling in .NET 8.</p>
<h3><a href="#aspnet-core-metrics" aria-hidden="true" class="anchor" id="aspnet-core-metrics"></a>ASP.NET Core metrics</h3>
<p><code>Metrics</code> are measurements reported over time and are most often used to monitor the health of an app and to generate alerts. For example, a counter that reports failed HTTP requests could be displayed in dashboards or generate alerts when failures pass a threshold.</p>
<p>This preview adds new metrics throughout ASP.NET Core using System.Diagnostics.Metrics. <code>Metrics</code> is a modern API for reporting and collecting information about apps.</p>
<p><code>Metrics</code> offers many improvements compared to existing event counters:</p>
<ul>
<li>
<p>New kinds of measurements with counters, gauges and histograms.</p>
</li>
<li>
<p>Powerful reporting with multi-dimensional values.</p>
</li>
<li>
<p>Integration into the wider cloud native ecosystem by aligning with OpenTelemetry standards.</p>
</li>
</ul>
<p><code>Metrics</code> have been added for ASP.NET Core hosting, Kestrel, and SignalR. For more information, see System.Diagnostics.Metrics.</p>
<h3><a href="#iexceptionhandler" aria-hidden="true" class="anchor" id="iexceptionhandler"></a><code>IExceptionHandler</code></h3>
<p><code>IExceptionHandler</code> is a new interface that gives the developer a callback for handling known exceptions in a central location.</p>
<p><code>IExceptionHandler</code> implementations are registered by calling <code>IServiceCollection.AddExceptionHandler&lt;T&gt;</code>. Multiple implementations can be added, and they're called in the order registered. If an exception handler handles a request, it can return <code>true</code> to stop processing. If an exception isn't handled by any exception handler, then control falls back to the default behavior and options from the middleware.</p>
<p>For more information, see <code>IExceptionHandler</code>.</p>
<h3><a href="#improved-debugging-experience" aria-hidden="true" class="anchor" id="improved-debugging-experience"></a>Improved debugging experience</h3>
<p>Debug customization attributes have been added to types like <code>HttpContext</code>, <code>HttpRequest</code>, <code>HttpResponse</code>, <code>ClaimsPrincipal</code>, and <code>WebApplication</code>. The enhanced debugger displays for these types make finding important information easier in an IDE's debugger. The following screenshots show the difference that these attributes make in the debugger's display of <code>HttpContext</code>.</p>
<p>.NET 7:</p>
<p>.NET 8:</p>
<p>The debugger display for <code>WebApplication</code> highlights important information such as configured endpoints, middleware, and <code>IConfiguration</code> values.</p>
<p>.NET 7:</p>
<p>.NET 8:</p>
<p>For more information about debugging improvements in .NET 8, see:</p>
<ul>
<li>
<p>Debugging Enhancements in .NET 8</p>
</li>
<li>
<p>GitHub issue dotnet/aspnetcore 48205</p>
</li>
</ul>
<h3><a href="#ipnetworkparse-and-tryparse" aria-hidden="true" class="anchor" id="ipnetworkparse-and-tryparse"></a><code>IPNetwork.Parse</code> and <code>TryParse</code></h3>
<p>The new Parse and <code>TryParse</code> methods on <code>IPNetwork</code> add support for creating an <code>IPNetwork</code> by using an input string in CIDR notation or &quot;slash notation&quot;.</p>
<p>Here are IPv4 examples:</p>
<pre><code class="language-csharp">// Using Parse
var network = IPNetwork.Parse(&quot;192.168.0.1/32&quot;);
</code></pre>
<pre><code class="language-csharp">// Using TryParse
bool success = IPNetwork.TryParse(&quot;192.168.0.1/32&quot;, out var network);
</code></pre>
<pre><code class="language-csharp">// Constructor equivalent
var network = new IPNetwork(IPAddress.Parse(&quot;192.168.0.1&quot;), 32);
</code></pre>
<p>And here are examples for IPv6:</p>
<pre><code class="language-csharp">// Using Parse
var network = IPNetwork.Parse(&quot;2001:db8:3c4d::1/128&quot;);
</code></pre>
<pre><code class="language-csharp">// Using TryParse
bool success = IPNetwork.TryParse(&quot;2001:db8:3c4d::1/128&quot;, out var network);
</code></pre>
<pre><code class="language-csharp">// Constructor equivalent
var network = new IPNetwork(IPAddress.Parse(&quot;2001:db8:3c4d::1&quot;), 128);
</code></pre>
<h3><a href="#redis-based-output-caching" aria-hidden="true" class="anchor" id="redis-based-output-caching"></a>Redis-based output caching</h3>
<p>ASP.NET Core 8 adds support for using as a distributed cache for output caching.</p>
<h3><a href="#short-circuit-middleware-after-routing" aria-hidden="true" class="anchor" id="short-circuit-middleware-after-routing"></a>Short-circuit middleware after routing</h3>
<p>When routing matches an endpoint, it typically lets the rest of the middleware pipeline run before invoking the endpoint logic. Services can reduce resource usage by filtering out known requests early in the pipeline. Use the ShortCircuit extension method to cause routing to invoke the endpoint logic immediately and then end the request. For example, a given route might not need to go through authentication or CORS middleware. The following example short-circuits requests that match the <code>/short-circuit</code> route:</p>
<pre><code class="language-csharp">app.MapGet(&quot;/short-circuit&quot;, () =&gt; &quot;Short circuiting!&quot;).ShortCircuit();
</code></pre>
<p>Use the MapShortCircuit method to set up short-circuiting for multiple routes at once, by passing to it a params array of URL prefixes. For example, browsers and bots often probe servers for well known paths like <code>robots.txt</code> and <code>favicon.ico</code>. If the app doesn't have those files, one line of code can configure both routes:</p>
<pre><code class="language-csharp">app.MapShortCircuit(404, &quot;robots.txt&quot;, &quot;favicon.ico&quot;);
</code></pre>
<p>For more information, see Short-circuit middleware after routing.</p>
<h3><a href="#http-logging-middleware-extensibility" aria-hidden="true" class="anchor" id="http-logging-middleware-extensibility"></a>HTTP logging middleware extensibility</h3>
<p>The HTTP logging middleware has several new capabilities:</p>
<ul>
<li>
<p><code>HttpLoggingFields.Duration</code>: When enabled, the middleware emits a new log at the end of the request and response that measures the total time taken for processing. This new field has been added to the <code>HttpLoggingFields.All</code> set.</p>
</li>
<li>
<p><code>HttpLoggingOptions.CombineLogs</code>: When enabled, the middleware consolidates all of its enabled logs for a request and response into one log at the end. A single log message includes the request, request body, response, response body, and duration.</p>
</li>
<li>
<p><code>IHttpLoggingInterceptor</code>: A new interface for a service that can be implemented and registered (using <code>AddHttpLoggingInterceptor</code>) to receive per-request and per-response callbacks for customizing what details get logged. Any endpoint-specific log settings are applied first and can then be overridden in these callbacks. An implementation can:</p>
<ul>
<li>
<p>Inspect a request and response.</p>
</li>
<li>
<p>Enable or disable any HttpLoggingFields.</p>
</li>
<li>
<p>Adjust how much of the request or response body is logged.</p>
</li>
<li>
<p>Add custom fields to the logs.</p>
</li>
</ul>
</li>
</ul>
<p>For more information, see HTTP logging in .NET Core and ASP.NET Core.</p>
<h3><a href="#new-apis-in-problemdetails-to-support-more-resilient-integrations" aria-hidden="true" class="anchor" id="new-apis-in-problemdetails-to-support-more-resilient-integrations"></a>New APIs in ProblemDetails to support more resilient integrations</h3>
<p>In .NET 8, a new API was added to make it easier to implement fallback behavior if <code>IProblemDetailsService</code> isn't able to generate <code>ProblemDetails</code>.</p>
<pre><code class="language-csharp">var builder = WebApplication.CreateBuilder(args);
builder.Services.AddProblemDetails();

var app = builder.Build();

app.UseExceptionHandler(exceptionHandlerApp =&gt;
{
    exceptionHandlerApp.Run(async httpContext =&gt;
    {
        var pds = httpContext.RequestServices.GetService&lt;IProblemDetailsService&gt;();
        if (pds == null
            || !await pds.TryWriteAsync(new() { HttpContext = httpContext }))
        {
            // Fallback behavior
            await httpContext.Response.WriteAsync(&quot;Fallback: An error occurred.&quot;);
        }
    });
});

app.MapGet(&quot;/exception&quot;, () =&gt;
{
    throw new InvalidOperationException(&quot;Sample Exception&quot;);
});

app.MapGet(&quot;/&quot;, () =&gt; &quot;Test by calling /exception&quot;);

app.Run();
</code></pre>
<p>For more information, see IProblemDetailsService fallback</p>
<h2><a href="#additional-resources" aria-hidden="true" class="anchor" id="additional-resources"></a>Additional resources</h2>
<ul>
<li>
<p>Announcing ASP.NET Core in .NET 8 (blog post)</p>
</li>
<li>
<p>ASP.NET Core announcements and breaking changes (aspnet/Announcements GitHub repository)</p>
</li>
<li>
<p>.NET announcements and breaking changes (dotnet/Announcements GitHub repository)</p>
</li>
</ul>
<p>Ref: <a href="https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-8.0?view=aspnetcore-8.0">What's new in ASP.NET Core 8.0</a></p>
 <div class='other-tags'><b>Tags:</b> <a class='topic-tag' href='/tags/Summary.html'>Summary</a><a class='topic-tag' href='/tags/AspNetCore.html'>AspNetCore</a></div>
      </div>
    </div>
  </body>
</html>
