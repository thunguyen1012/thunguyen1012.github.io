---
title: Entity Framework - Entity Framework Core - Create a model - Keys
published: true
date: 2024-07-22 09:46:11
tags: EFCore, Summary
description: A key is a unique identifier for an entity instance.
image:
---
- Article

  - 11/23/2022

  - 12 contributors

## In this article

A key is a unique identifier for an entity instance.

## Configuring a primary key

By convention, a property named ```Id``` or ```<type name>Id``` will be configured as the primary key of an entity.

```csharp
internal class Car
{
    public string Id { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

internal class Truck
{
    public string TruckId { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

> Note
Owned entity types use different rules to define keys.

You can configure a single property to be the primary key of an entity as follows:

 - Data Annotations

 - Fluent API

```csharp
internal class Car
{
    [Key]
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasKey(c => c.LicensePlate);
}
```

You can set a single property to be the key of an entity - this is known as a convention.

 - Data Annotations

 - Fluent API

> Note
The [PrimaryKey] attribute was introduced in EF Core 7.0. Use the Fluent API in older versions.

```csharp
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}
```

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasKey(c => new { c.State, c.LicensePlate });
}
```

## Value generation

EF Core sets up inheritance mappings for composite numeric and GUID primary keys.

## Primary key name

By convention, on relational databases primary keys are created with the name PK_<type name>. You can configure the name of the primary key constraint as follows:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .HasKey(b => b.BlogId)
        .HasName("PrimaryKey_BlogId");
}
```

## Key types and values

EF Core supports using properties of any primitive type as the primary key, including ```string```, ```Guid```, byte[] and others, not all databases support all types as keys.

EF will try to generate a temporary value when an entity is added to the context.

> Important
If a key property has its value generated by the database and a non-default value is specified when an entity is added, then EF will assume that the entity already exists in the database and will try to update it instead of inserting a new one. To avoid this, turn off value generation or see how to specify explicit values for generated properties.

## Alternate Keys

An alternate key is a unique identifier for each entity instance in addition to the primary key.

> Tip
If you just want to enforce uniqueness on a column, define a unique index rather than an alternate key (see Indexes). In EF, alternate keys are read-only and provide additional semantics over unique indexes because they can be used as the target of a foreign key.

An alternate key is a key which is not the primary key for a relationship.

```csharp
internal class MyContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Post>()
            .HasOne(p => p.Blog)
            .WithMany(b => b.Posts)
            .HasForeignKey(p => p.BlogUrl)
            .HasPrincipalKey(b => b.Url);
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    public List<Post> Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public string BlogUrl { get; set; }
    public Blog Blog { get; set; }
}
```

You can also configure a single property to be an alternate key:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => c.LicensePlate);
}
```

You can also configure multiple properties to be an alternate key (known as a composite alternate key):

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => new { c.State, c.LicensePlate });
}
```

You can specify the name of the alternate key's index and unique constraint by specifying AK_type name>_property name> (for composite alternate keys property name> becomes an underscore separated list of property names).

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => c.LicensePlate)
        .HasName("AlternateKey_LicensePlate");
}
```

Ref: [Keys](https://learn.microsoft.com/en-us/ef/core/modeling/keys)